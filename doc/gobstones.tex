\documentclass{article}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage[spanish]{babel}
\begin{document}
\newcommand{\chr}[1]{\texttt{'}\textcolor{blue}{\texttt{#1}}\texttt{'}}
\newcommand{\str}[1]{\texttt{"}\textcolor{blue}{\texttt{#1}}\texttt{"}}
\newcommand{\tok}[1]{\textcolor{red}{\texttt{#1}}}
\newcommand{\symbolentry}[3]{#1 & #2 && #3 \\}
\newcommand{\nb}[1]{\footnotesize{#1}}
\newcommand{\s}[1]{\textcolor{blue}{{\it$\langle$#1$\rangle$}}}
\newcommand{\nonEmpty}[1]{#1$_{1}$}
\newcommand{\produccion}[2]{
  \noindent
  \begin{tabularx}{\textwidth}{lrlr}
  #1 & $\xrightarrow{\hspace{.5cm}}$ & #2
  \end{tabularx}\\
}
\newcommand{\EMPTY}{$\epsilon$}
\newcommand{\ALT}{
  \\ & $\mid$ &
}
\newcommand{\ALTA}{
  $\mid$
}
\newcommand{\TODO}[1]{\textcolor{red}{****#1****}}
\section{Gram\'atica de XGobstones}

\subsection{Sintaxis l\'exica}

\begin{itemize}
\item Se ignoran:
\chr{\textbackslash t} (\texttt{TAB}, chr 8),
\chr{\textbackslash n} (\texttt{LF}, chr 10),
\chr{\textbackslash r} (\texttt{CR}, chr 13),
\chr{\,} (\texttt{SPACE}, chr 32).
\item Se admiten comentarios comenzados por \str{//} (estilo C++), por \str{--} (estilo Haskell) y por \str{\#} (estilo shell) que se extienden hasta el fin de l\'inea (\texttt{LF}).
\item Se admiten comentarios delimitados por \str{/*} \str{*/} y por \str{\{-} \str{-\}} que pueden anidarse.
\item El tokenizador reconoce directivas {\em pragma} de la forma \str{/*@parte$_1$@parte$_2$@...@parte$_n$@*/}. La idea es que esto pueda ser un mecanismo extensible de directivas. Ver m\'as abajo las directivas soportadas.
\end{itemize}


\subsection{Lista de s\'imbolos terminales}

Todos los s\'imbolos terminales se acompa\~nan de su nombre \tok{EN\_MAYUSCULAS}.\bigskip

\noindent{\bf Identificadores y constantes}\medskip\\
\begin{tabularx}{\textwidth}{llXp{4cm}}
\symbolentry{\texttt{0|[1-9][0-9]*}}{\tok{NUM}}{\nb{Constante num\'erica (sin ceros a la izquierda).}}
\symbolentry{\texttt{[a-z][\_a-zA-Z0-9']*}}{\tok{LOWERID}}{\nb{Identificador en min\'uscula: \'indices, par\'ametros, funciones, variables, campos.}}
\symbolentry{\texttt{[A-Z][\_a-zA-Z0-9']*}}{\tok{UPPERID}}{\nb{Identificador en may\'uscula: constructores, procedimientos, tipos.}}
\symbolentry{\texttt{"(\textbackslash{a}|\textbackslash{b}|\textbackslash{f}|\textbackslash{n}|\textbackslash{r}|\textbackslash{t}|\textbackslash{v}|\textbackslash\textbackslash|\textbackslash"|[\^{}\textbackslash"])*"}}{\tok{STRING}}{\nb{Constante de cadena.}}
\end{tabularx}
\medskip

Clarificaci\'on sobre las constantes de {\em string}:
las cadenas est\'an delimitadas por comillas dobles (\chr{"}).
Todos los caracteres desde la comilla que abre hasta la que cierra se
toman literalmente salvo la contrabarra (\chr{\textbackslash}) que se
interpreta como un caracter de escape.
Los escapes admitidos son:
\begin{center}
\texttt{\textbackslash\textbackslash}
\hspace{1cm}
\texttt{\textbackslash"}
\end{center}
\begin{center}
\texttt{\textbackslash{a}}
\hspace{1cm}
\texttt{\textbackslash{b}}
\hspace{1cm}
\texttt{\textbackslash{f}}
\hspace{1cm}
\texttt{\textbackslash{n}}
\hspace{1cm}
\texttt{\textbackslash{r}}
\hspace{1cm}
\texttt{\textbackslash{t}}
\hspace{1cm}
\texttt{\textbackslash{v}}
\end{center}
con su significado acostumbrado en la tradici\'on de C
({\em cf.} la gram\'atica oficial de Gobstones).
\bigskip

\noindent{\bf Palabras clave}\medskip\\
\begin{tabularx}{\textwidth}{llXp{10cm}}
\symbolentry{\texttt{program}}{\tok{PROGRAM}}{\nb{Para declarar la rutina principal.}}
\symbolentry{\texttt{interactive}}{\tok{INTERACTIVE}}{\nb{Para declarar una rutina principal interactiva con \texttt{interactive program}.}}
\symbolentry{\texttt{procedure}}{\tok{PROCEDURE}}{\nb{Para declarar procedimientos.}}
\symbolentry{\texttt{function}}{\tok{FUNCTION}}{\nb{Para declarar funciones.}}
\symbolentry{\texttt{return}}{\tok{RETURN}}{\nb{Para devolver valores de funciones y de la rutina principal.}}
\symbolentry{\texttt{if}}{\tok{IF}}{\nb{Para la alternativa condicional.}}
\symbolentry{\texttt{then}}{\tok{THEN}}{\nb{Palabra clave opcional para la rama ``then''.}}
\symbolentry{\texttt{else}}{\tok{ELSE}}{\nb{Para la rama ``else''.}}
\symbolentry{\texttt{repeat}}{\tok{REPEAT}}{\nb{Repetici\'on simple.}}
\symbolentry{\texttt{foreach}}{\tok{FOREACH}}{\nb{Repetici\'on indexada.}}
\symbolentry{\texttt{in}}{\tok{IN}}{\nb{Para declarar el rango de la repetici\'on indexada.}}
\symbolentry{\texttt{while}}{\tok{WHILE}}{\nb{Repetici\'on condicional.}}
\symbolentry{\texttt{switch}}{\tok{SWITCH}}{\nb{Para hacer {\em pattern matching}.}}
\symbolentry{\texttt{match}}{\tok{SWITCH}}{\nb{Alternativa para \texttt{switch}.}}
\symbolentry{\texttt{to}}{\tok{TO}}{\nb{Palabra clave opcional despu\'es del sujeto sobre el que se hace {\em pattern matching}.}}
\symbolentry{\texttt{let}}{\tok{LET}}{\nb{Palabra clave opcional para la asignaci\'on. Es obligatoria en el caso de las asignaciones que hacen {\em destructuring} de tuplas.}}
\symbolentry{\texttt{not}}{\tok{NOT}}{\nb{Negaci\'on l\'ogica.}}
\symbolentry{\texttt{mod}}{\tok{MOD}}{\nb{Resto de la divisi\'on entera.}}
\symbolentry{\texttt{div}}{\tok{DIV}}{\nb{Cociente de la divisi\'on entera.}}
\symbolentry{\texttt{type}}{\tok{TYPE}}{\nb{Para la declaraci\'on de nuevos tipos.}}
\symbolentry{\texttt{is}}{\tok{IS}}{\nb{Palabra clave para acompa\~nar la declaraci\'on de un nuevo tipo.}}
\symbolentry{\texttt{record}}{\tok{RECORD}}{\nb{Para tipos registro.}}
\symbolentry{\texttt{variant}}{\tok{VARIANT}}{\nb{Para tipos variantes.}}
\symbolentry{\texttt{case}}{\tok{CASE}}{\nb{Para las alternativas de tipos variantes.}}
\symbolentry{\texttt{field}}{\tok{FIELD}}{\nb{Para los campos de tipos registro.}}
\symbolentry{\texttt{\_}}{\tok{UNDERSCORE}}{\nb{Para marcar el caso ``default'' en un switch/match.}}
\end{tabularx}\bigskip

\noindent{\bf S\'imbolos}\medskip\\
\begin{tabularx}{\textwidth}{llXp{10cm}}
\symbolentry{\texttt{(}}{\tok{LPAREN}}{\nb{Par\'entesis izquierdo.}}
\symbolentry{\texttt{)}}{\tok{RPAREN}}{\nb{Par\'entesis derecho.}}
\symbolentry{\texttt{\{}}{\tok{LBRACE}}{\nb{Llave izquierda.}}
\symbolentry{\texttt{\}}}{\tok{RBRACE}}{\nb{Llave derecha.}}
\symbolentry{\texttt{[}}{\tok{LBRACK}}{\nb{Corchete izquierdo (para listas y rangos).}}
\symbolentry{\texttt{]}}{\tok{RBRACK}}{\nb{Corchete derecho.}}
\symbolentry{\texttt{,}}{\tok{COMMA}}{\nb{Coma.}}
\symbolentry{\texttt{;}}{\tok{SEMICOLON}}{\nb{Punto y coma (separador de instrucciones opcional).}}
\symbolentry{\texttt{..}}{\tok{RANGE}}{\nb{Para rangos, p.ej. \texttt{[1..10]}.}}
\symbolentry{\texttt{:=}}{\tok{ASSIGN}}{\nb{Asignaci\'on.}}
\symbolentry{\texttt{\&\&}}{\tok{AND}}{\nb{Conjunci\'on.}}
\symbolentry{\texttt{||}}{\tok{OR}}{\nb{Disyunci\'on.}}
\symbolentry{\texttt{<-}}{\tok{GETS}}{\nb{Para inicializar campos, p.ej. \texttt{Coord(x <- 1, y <- 2)}.}}
\symbolentry{\texttt{|}}{\tok{PIPE}}{\nb{Para actualizar campos, p.ej. \texttt{Coord(c | x <- 2)}.}}
\symbolentry{\texttt{->}}{\tok{ARROW}}{\nb{Usado en las ramas de un \texttt{switch}, p.ej. \texttt{Norte ->\ \{r := 1\}}.}}
\symbolentry{\texttt{==}}{\tok{EQ}}{\nb{Comparaci\'on por igualdad.}}
\symbolentry{\texttt{/=}}{\tok{NE}}{\nb{Comparaci\'on por desigualdad.}}
\symbolentry{\texttt{<=}}{\tok{LE}}{\nb{Comparaci\'on por menor o igual.}}
\symbolentry{\texttt{>=}}{\tok{GE}}{\nb{Comparaci\'on por mayor o igual.}}
\symbolentry{\texttt{<}}{\tok{LT}}{\nb{Comparaci\'on por menor estricto.}}
\symbolentry{\texttt{>}}{\tok{LT}}{\nb{Comparaci\'on por mayor estricto.}}
\symbolentry{\texttt{++}}{\tok{CONCAT}}{\nb{Operador de concatenaci\'on de listas.}}
\symbolentry{\texttt{+}}{\tok{PLUS}}{\nb{Suma de n\'umeros.}}
\symbolentry{\texttt{-}}{\tok{MINUS}}{\nb{Resta de n\'umeros y menos unario.}}
\symbolentry{\texttt{*}}{\tok{TIMES}}{\nb{Producto de n\'umeros.}}
\symbolentry{\texttt{\^}}{\tok{POW}}{\nb{Potencia.}}
\end{tabularx}\bigskip

\subsection{Pragmas}

El tokenizador implementa directivas pragma para
mantener registro de ``regiones''. Una regi\'on es una cadena de texto que
sirve para identificar o {\em taggear} un fragmento del programa.
Las regiones no tienen ning\'un significado
especial para el int\'erprete de Gobstones, pero todas las excepciones que
eleva el int\'erprete vienen acompa\~nadas de una posici\'on que incluye
el nombre de la regi\'on actual. Las regiones pueden anidarse.
Este comportamiento se implementa por medio de dos directivas.
\begin{itemize}
\item \str{/*@BEGIN\_REGION@\textit{nombre\_de\_la\_regi\'on}@*/}:
       mete el nombre de una regi\'on en la pila de regiones.
\item \str{/*@END\_REGION@*/}: saca la regi\'on del tope de la pila de regiones.
\end{itemize}
Por ejemplo ante el siguiente programa:
\begin{verbatim}
/*@BEGIN_REGION@A@*/
procedure P() {
  /*@BEGIN_REGION@B@*/
  x := f(
  /*@END_REGION@*/
}
/*@END_REGION@*/
\end{verbatim}
El parser idealmente deber\'ia reportar que hay un error de sintaxis en la regi\'on \texttt{B}.

\subsection{Gram\'atica}
Los s\'imbolos no terminales se describen con su nombre \s{enCursiva}.
Las producciones se escriben siguiendo las convenciones usuales de EBNF.
La gram\'atica es liberal en algunos sentidos. En particular:
\begin{itemize}
\item El \texttt{return}
se considera un {\em statement} que puede aparecer en la posici\'on en la que
podr\'ia aparecer cualquier otra instrucci\'on. La restricci\'on de que
el \texttt{return} \'unicamente aparezca como \'ultima instrucci\'on del bloque, y
\'unicamente al final de las declaraciones de funciones y del programa principal,
es una restricci\'on que se posterga para la etapa de chequeo sem\'antico
({\em lint}).
\item Se admite el gui\'on bajo (\chr{\_}) como un posible patr\'on en el lado
izquierdo de las ramas de un \texttt{switch} y en el lado izquierdo de las ramas de un.
\texttt{interactive program}.
En una lista de ramas deber\'ia haber un \'unico gui\'on bajo, y deber\'ia ser el \'ultimo
patr\'on de la lista pero esto, de nuevo, se relega a la etapa de lint.
\end{itemize}

Las convenciones de asociatividad y precedencia de operadores no se reflejan
en las producciones, sino en la tabla de precedencia.
(Para expresar esto en la gram\'atica ser\'ia necesario estratificar las expresiones
en t\'erminos, factores, \'atomos, etc., tal como se hace en la gram\'atica oficial).
\bigskip

\produccion{\s{start}}{\s{definition}*}

\produccion{\s{definition}}{
\s{defProgram}
\ALT
\s{defInteractiveProgram}
\ALT
\s{defProcedure}
\ALT
\s{defFunction}
\ALT
\s{defType}
}

\produccion{\s{defProgram}}{
  \tok{PROGRAM} \s{stmtBlock}
}

\produccion{\s{defInteractiveProgram}}{
  \TODO{TODO}
}

\produccion{\s{defProcedure}}{
  \tok{PROCEDURE} \tok{LPAREN} \s{loweridSeq} \tok{RPAREN} \s{stmtBlock}
}

\produccion{\s{defFunction}}{
  \tok{FUNCTION} \tok{LPAREN} \s{loweridSeq} \tok{RPAREN} \s{stmtBlock}
}

\produccion{\s{defType}}{
  \tok{TYPE} \tok{UPPERID} \tok{IS} \tok{RECORD} \tok{LBRACE} \s{fieldDeclaration}* \tok{RBRACE}
\ALT
  \tok{TYPE} \tok{UPPERID} \tok{IS} \tok{VARIANT} \tok{LBRACE} \s{constructorDeclaration}* \tok{RBRACE}
}

\produccion{\s{constructorDeclaration}}{
  \tok{CASE} \tok{UPPERID} \tok{LBRACE} \s{fieldDeclaration}* \tok{RBRACE}
}

\produccion{\s{fieldDeclaration}}{
  \tok{FIELD} \tok{LOWERID}
}

\produccion{\s{loweridSeq}}{
  \EMPTY
\ALT
  \s{\nonEmpty{loweridSeq}}
}

\produccion{\s{\nonEmpty{loweridSeq}}}{
  \tok{LOWERID} (\tok{COMMA} \s{\nonEmpty{loweridSeq}})?
}

\noindent {\bf Statements.}

\produccion{\s{statement}}{
  \s{stmtBlock}
\ALT
  \s{stmtReturn}
\ALT
  \s{stmtIf}
\ALT
  \s{stmtRepeat}
\ALT
  \s{stmtForeach}
\ALT
  \s{stmtWhile}
\ALT
  \s{stmtSwitch}
\ALT
  \s{stmtLet}
\ALT
  \s{stmtVariableAssignment}
\ALT
  \s{stmtProcedureCall}
}

\produccion{\s{stmtBlock}}{
  \tok{LBRACE} (\s{statement} \tok{SEMICOLON}?)* \tok{RBRACE}
}

\produccion{\s{stmtReturn}}{
  \tok{RETURN} \tok{LPAREN} \s{expressionSeq} \tok{RPAREN}
}

\produccion{\s{stmtIf}}{
  \tok{IF} \tok{LPAREN} \s{expression} \tok{RPAREN} 
           \tok{THEN}? \s{stmtBlock}
           (\tok{ELSE} \s{stmtBlock})?
}

\produccion{\s{stmtRepeat}}{
  \tok{REPEAT} \tok{LPAREN} \s{expression} \tok{RPAREN} \s{stmtBlock}
}

\produccion{\s{stmtForeach}}{
  \tok{FOREACH} \tok{LOWERID} \tok{IN} \s{expression} \s{stmtBlock}
}

\produccion{\s{stmtWhile}}{
  \tok{WHILE} \tok{LPAREN} \s{expression} \tok{RPAREN} \s{stmtBlock}
}

\produccion{\s{stmtSwitch}}{
  \tok{SWITCH} \tok{LPAREN} \s{expression} \tok{RPAREN} \tok{TO}? \tok{LBRACE} \s{stmtSwitchBranch}* \tok{RBRACE}
}

\produccion{\s{stmtSwitchBranch}}{
  \s{pattern} \tok{ARROW} \s{stmtBlock}
}

\produccion{\s{stmtLet}}{
  \tok{LET} \s{stmtVariableAssignment}
\ALT
  \tok{LET} \s{stmtTupleAssignment}
}

\produccion{\s{stmtVariableAssignment}}{
  \tok{LOWERID} \tok{ASSIGN} \s{expression}
}

\produccion{\s{stmtTupleAssignment}}{
  \tok{LPAREN} \tok{RPAREN} \tok{ASSIGN} \s{expression}
\ALT
  \tok{LPAREN} \tok{LOWERID} \tok{COMMA} \s{\nonEmpty{loweridSeq}} \tok{RPAREN} \tok{ASSIGN} \s{expression}
}

\produccion{\s{stmtProcedureCall}}{
  \tok{UPPERID} \tok{LPAREN} \s{expressionSeq} \tok{RPAREN}
}

\noindent {\bf Patterns.}

\produccion{\s{pattern}}{
  \s{patternWildcard}
\ALT
  \s{patternConstructor}
\ALT
  \s{patternTuple}
}

\produccion{\s{patternWildcard}}{
  \tok{UNDERSCORE}
}

\produccion{\s{patternConstructor}}{
  \tok{UPPERID} (\tok{LPAREN} \s{loweridSeq} \tok{RPAREN})?
}

\produccion{\s{patternTuple}}{
  \tok{LPAREN} \tok{RPAREN}
\ALT
  \tok{LPAREN} \tok{LOWERID} \tok{COMMA} \s{\nonEmpty{loweridSeq}} \tok{RPAREN}
}

\noindent {\bf Expressions.}

\produccion{\s{expression}}{
  \s{exprAtom}
\ALT
  \s{expression} \s{infixOperator} \s{expression}
\ALT
  \s{prefixOperator} \s{expression}
\ALT
  \tok{LPAREN} \s{expression} \tok{RPAREN}
}

\produccion{\s{exprAtom}}{
  \s{exprVariable}
\ALT
  \s{exprFunctionCall}
\ALT
  \s{exprConstantNumber}
\ALT
  \s{exprConstantString}
\ALT
  \s{exprList}
\ALT
  \s{exprRange}
\ALT
  \s{exprTuple}
\ALT
  \s{exprConstructor}
\ALT
  \s{exprConstructorUpdate}
}

\produccion{\s{exprVariable}}{
  \tok{LOWERID}
}

\produccion{\s{exprFunctionCall}}{
  \tok{LOWERID} \tok{LPAREN} \s{expressionSeq} \tok{RPAREN}
}

\produccion{\s{exprConstantNumber}}{
  \tok{NUM}
}

\produccion{\s{exprConstantString}}{
  \tok{STRING}
}

\produccion{\s{exprList}}{
  \tok{LBRACK} \s{expressionSeq} \tok{RBRACK}
}

\produccion{\s{exprRange}}{
  \tok{LBRACK} \s{expression} \tok{RANGE} \s{expression} \tok{RBRACK}
\ALT
  \tok{LBRACK} \s{expression} \tok{COMMA} \s{expression} \tok{RANGE} \s{expression} \tok{RBRACK}
}

\produccion{\s{exprTuple}}{
  \tok{LPAREN} \tok{RPAREN}
\ALT
  \tok{LPAREN} \s{expression} \tok{COMMA} \s{\nonEmpty{expressionSeq}} \tok{RPAREN}
}

\produccion{\s{exprConstructor}}{
  \tok{UPPERID} (\tok{LPAREN} \s{fieldValueSeq} \tok{RPAREN})?
}

\produccion{\s{exprConstructorUpdate}}{
  \tok{UPPERID} \tok{LPAREN} \s{expression} \tok{PIPE} \s{fieldValueSeq} \tok{RPAREN}
}

\produccion{\s{fieldValue}}{
  \tok{LOWERID} \tok{GETS} \s{expression}
}

\produccion{\s{fieldValueSeq}}{
  \EMPTY
\ALT
  \s{\nonEmpty{fieldValueSeq}}
}

\produccion{\s{\nonEmpty{fieldValueSeq}}}{
  \s{fieldValue} (\tok{COMMA} \s{\nonEmpty{fieldValueSeq}})?
}

\produccion{\s{infixOperator}}{
  \tok{OR}
\ALTA
  \tok{AND}
\ALTA
  \tok{EQ}
\ALTA
  \tok{NE}
\ALTA
  \tok{LE}
\ALTA
  \tok{GE}
\ALTA
  \tok{LT}
\ALTA
  \tok{GT}
\ALTA
  \tok{CONCAT}
\ALT
  \tok{PLUS}
\ALTA
  \tok{MINUS}
\ALTA
  \tok{TIMES}
\ALTA
  \tok{DIV}
\ALTA
  \tok{MOD}
\ALTA
  \tok{POW}
}

\produccion{\s{prefixOperator}}{
  \tok{MINUS}
\ALT
  \tok{NOT}
}

\produccion{\s{expressionSeq}}{
  \EMPTY
\ALT
  \s{\nonEmpty{expressionSeq}}
}

\produccion{\s{\nonEmpty{expressionSeq}}}{
  \s{expression} (\tok{COMMA} \s{\nonEmpty{expressionSeq}})?
}

\subsubsection{Precedencia de operadores}

Los operadores se organizan seg\'un la siguiente tabla.
Cada fila corresponde a un nivel de precedencia, ordenados de menor a mayor precedencia.
Las {\em fixities} posibles son:
operador binario asociativo a derecha ({\bf InfixR}),
operador binario asociativo a izquierda ({\bf InfixL}),
operador binario no asociativo ({\bf Infix}),
operador unario prefijo ({\bf Prefix}).

\begin{itemize}
\item {\bf InfixR:} \tok{OR} (\texttt{||})
\item {\bf InfixR:} \tok{AND} (\texttt{\&\&})
\item {\bf Prefix:} \tok{NOT} (\texttt{not})
\item {\bf Infix:}
  \tok{EQ} (\texttt{==})
  \tok{NE} (\texttt{/=})
  \tok{LE} (\texttt{<=})
  \tok{GE} (\texttt{>=})
  \tok{LT} (\texttt{<})
  \tok{GT} (\texttt{>})
\item {\bf InfixL:}
  \tok{CONCAT} (\texttt{++})
\item {\bf InfixL:}
  \tok{PLUS} (\texttt{+})
  \tok{MINUS} (\texttt{-})
\item {\bf InfixL:}
  \tok{TIMES} (\texttt{*})
\item {\bf InfixL:}
  \tok{DIV} (\texttt{div})
  \tok{MOD} (\texttt{mod})
\item {\bf InfixR:}
  \tok{POW} (\texttt{\^})
\item {\bf Prefix:}
  \tok{MINUS} (\texttt{-}, menos unario)
\end{itemize}

\end{document}
