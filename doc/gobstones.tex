\documentclass{article}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage[spanish]{babel}
\begin{document}
\newcommand{\chr}[1]{\texttt{'}\textcolor{blue}{\texttt{#1}}\texttt{'}}
\newcommand{\str}[1]{\texttt{"}\textcolor{blue}{\texttt{#1}}\texttt{"}}
\newcommand{\tok}[1]{\textcolor{red}{\texttt{#1}}}
\newcommand{\symbolentry}[3]{#1 & #2 && #3 \\}
\newcommand{\nb}[1]{\footnotesize{#1}}
\newcommand{\s}[1]{\textcolor{blue}{{\it$\langle$#1$\rangle$}}}
\newcommand{\nonEmpty}[1]{#1$_{1}$}
\newcommand{\produccion}[2]{
  \noindent
  \begin{tabularx}{\textwidth}{lrlr}
  #1 & $\xrightarrow{\hspace{.5cm}}$ & #2
  \end{tabularx}\\
}
\newcommand{\EMPTY}{$\epsilon$}
\newcommand{\ALT}{
  \\ & $\mid$ &
}
\newcommand{\TODO}[1]{\textcolor{red}{****#1****}}
\section{Gram\'atica de XGobstones}

\subsection{Sintaxis l\'exica}

\begin{itemize}
\item Se ignoran:
\chr{\textbackslash t} (\texttt{TAB}, chr 8),
\chr{\textbackslash n} (\texttt{LF}, chr 10),
\chr{\textbackslash r} (\texttt{CR}, chr 13),
\chr{\,} (\texttt{SPACE}, chr 32).
\item Se admiten comentarios comenzados por \str{//} y por \str{--} que se extienden hasta el fin de l\'inea (\texttt{LF}).
\item Se admiten comentarios delimitados por \str{/*} \str{*/} y por \str{\{-} \str{-\}} que pueden anidarse.
\item El tokenizador reconoce directivas {\em pragma} de la forma \str{/*@parte$_1$@parte$_2$@...@parte$_n$@*/}. La idea es que esto pueda ser un mecanismo extensible de directivas. Ver m\'as abajo las directivas soportadas.
\end{itemize}


\subsection{Lista de s\'imbolos terminales}

Todos los s\'imbolos terminales se acompa\~nan de su nombre \tok{EN\_MAYUSCULAS}.\bigskip

\noindent{\bf Identificadores y constantes}\medskip\\
\begin{tabularx}{\textwidth}{llXp{4cm}}
\symbolentry{\texttt{0|[1-9][0-9]*}}{\tok{NUM}}{\nb{Constante num\'erica (sin ceros a la izquierda).}}
\symbolentry{\texttt{[a-z][\_a-zA-Z0-9]*}}{\tok{LOWERID}}{\nb{Identificador en min\'uscula: \'indices, par\'ametros, funciones, variables, campos.}}
\symbolentry{\texttt{[A-Z][\_a-zA-Z0-9]*}}{\tok{UPPERID}}{\nb{Identificador en may\'uscula: constructores, procedimientos, tipos.}}
\symbolentry{\texttt{"(\textbackslash{a}|\textbackslash{b}|\textbackslash{f}|\textbackslash{n}|\textbackslash{r}|\textbackslash{t}|\textbackslash{v}|\textbackslash\textbackslash|\textbackslash"|[\^{}\textbackslash"])*"}}{\tok{STRING}}{\nb{Constante de cadena.}}
\end{tabularx}
\medskip

Clarificaci\'on sobre las constantes de {\em string}:
las cadenas est\'an delimitadas por comillas dobles (\chr{"}).
Todos los caracteres desde la comilla que abre hasta la que cierra se
toman literalmente salvo la contrabarra (\chr{\textbackslash}) que se
interpreta como un caracter de escape.
Los escapes admitidos son:
\begin{center}
\texttt{\textbackslash\textbackslash}
\hspace{1cm}
\texttt{\textbackslash"}
\end{center}
\begin{center}
\texttt{\textbackslash{a}}
\hspace{1cm}
\texttt{\textbackslash{b}}
\hspace{1cm}
\texttt{\textbackslash{f}}
\hspace{1cm}
\texttt{\textbackslash{n}}
\hspace{1cm}
\texttt{\textbackslash{r}}
\hspace{1cm}
\texttt{\textbackslash{t}}
\hspace{1cm}
\texttt{\textbackslash{v}}
\end{center}
con su significado acostumbrado en la tradici\'on de C
({\em cf.} la gram\'atica oficial de Gobstones).
\bigskip

\noindent{\bf Palabras clave}\medskip\\
\begin{tabularx}{\textwidth}{llXp{10cm}}
\symbolentry{\texttt{program}}{\tok{PROGRAM}}{\nb{Para declarar la rutina principal.}}
\symbolentry{\texttt{interactive}}{\tok{INTERACTIVE}}{\nb{Para declarar una rutina principal interactiva con \texttt{interactive program}.}}
\symbolentry{\texttt{procedure}}{\tok{PROCEDURE}}{\nb{Para declarar procedimientos.}}
\symbolentry{\texttt{function}}{\tok{FUNCTION}}{\nb{Para declarar funciones.}}
\symbolentry{\texttt{return}}{\tok{RETURN}}{\nb{Para devolver valores de funciones y de la rutina principal.}}
\symbolentry{\texttt{if}}{\tok{IF}}{\nb{Para la alternativa condicional.}}
\symbolentry{\texttt{then}}{\tok{THEN}}{\nb{Palabra clave opcional para la rama ``then''.}}
\symbolentry{\texttt{else}}{\tok{ELSE}}{\nb{Para la rama ``else''.}}
\symbolentry{\texttt{repeat}}{\tok{REPEAT}}{\nb{Repetici\'on simple.}}
\symbolentry{\texttt{foreach}}{\tok{FOREACH}}{\nb{Repetici\'on indexada.}}
\symbolentry{\texttt{in}}{\tok{IN}}{\nb{Para declarar el rango de la repetici\'on indexada.}}
\symbolentry{\texttt{while}}{\tok{WHILE}}{\nb{Repetici\'on condicional.}}
\symbolentry{\texttt{switch}}{\tok{SWITCH}}{\nb{Para hacer {\em pattern matching}.}}
\symbolentry{\texttt{match}}{\tok{SWITCH}}{\nb{Alternativa para \texttt{switch}.}}
\symbolentry{\texttt{to}}{\tok{TO}}{\nb{Palabra clave opcional despu\'es del sujeto sobre el que se hace {\em pattern matching}.}}
\symbolentry{\texttt{let}}{\tok{LET}}{\nb{Palabra clave opcional para la asignaci\'on. Es obligatoria en el caso de las asignaciones que hacen {\em destructuring} de tuplas.}}
\symbolentry{\texttt{not}}{\tok{NOT}}{\nb{Negaci\'on l\'ogica.}}
\symbolentry{\texttt{mod}}{\tok{MOD}}{\nb{Resto de la divisi\'on entera.}}
\symbolentry{\texttt{div}}{\tok{DIV}}{\nb{Cociente de la divisi\'on entera.}}
\symbolentry{\texttt{type}}{\tok{TYPE}}{\nb{Para la declaraci\'on de nuevos tipos.}}
\symbolentry{\texttt{is}}{\tok{IS}}{\nb{Palabra clave para acompa\~nar la declaraci\'on de un nuevo tipo.}}
\symbolentry{\texttt{record}}{\tok{RECORD}}{\nb{Para tipos registro.}}
\symbolentry{\texttt{variant}}{\tok{VARIANT}}{\nb{Para tipos variantes.}}
\symbolentry{\texttt{case}}{\tok{CASE}}{\nb{Para las alternativas de tipos variantes.}}
\symbolentry{\texttt{field}}{\tok{FIELD}}{\nb{Para los campos de tipos registro.}}
\symbolentry{\texttt{\_}}{\tok{UNDERSCORE}}{\nb{Para marcar el caso ``default'' en un switch/match.}}
\end{tabularx}\bigskip

\noindent{\bf S\'imbolos}\medskip\\
\begin{tabularx}{\textwidth}{llXp{10cm}}
\symbolentry{\texttt{(}}{\tok{LPAREN}}{\nb{Par\'entesis izquierdo.}}
\symbolentry{\texttt{)}}{\tok{RPAREN}}{\nb{Par\'entesis derecho.}}
\symbolentry{\texttt{\{}}{\tok{LBRACE}}{\nb{Llave izquierda.}}
\symbolentry{\texttt{\}}}{\tok{RBRACE}}{\nb{Llave derecha.}}
\symbolentry{\texttt{[}}{\tok{LBRACK}}{\nb{Corchete izquierdo (para listas y rangos).}}
\symbolentry{\texttt{]}}{\tok{RBRACK}}{\nb{Corchete derecho.}}
\symbolentry{\texttt{,}}{\tok{COMMA}}{\nb{Coma.}}
\symbolentry{\texttt{;}}{\tok{SEMICOLON}}{\nb{Punto y coma (separador de instrucciones opcional).}}
\symbolentry{\texttt{..}}{\tok{RANGE}}{\nb{Para rangos, p.ej. \texttt{[1..10]}.}}
\symbolentry{\texttt{:=}}{\tok{ASSIGN}}{\nb{Asignaci\'on.}}
\symbolentry{\texttt{\&\&}}{\tok{AND}}{\nb{Conjunci\'on.}}
\symbolentry{\texttt{||}}{\tok{OR}}{\nb{Disyunci\'on.}}
\symbolentry{\texttt{<-}}{\tok{GETS}}{\nb{Para inicializar campos, p.ej. \texttt{Coord(x <- 1, y <- 2)}.}}
\symbolentry{\texttt{|}}{\tok{PIPE}}{\nb{Para actualizar campos, p.ej. \texttt{Coord(c | x <- 2)}.}}
\symbolentry{\texttt{->}}{\tok{ARROW}}{\nb{Usado en las ramas de un \texttt{switch}, p.ej. \texttt{Norte ->\ \{r := 1\}}.}}
\symbolentry{\texttt{==}}{\tok{EQ}}{\nb{Comparaci\'on por igualdad.}}
\symbolentry{\texttt{/=}}{\tok{NE}}{\nb{Comparaci\'on por desigualdad.}}
\symbolentry{\texttt{<=}}{\tok{LE}}{\nb{Comparaci\'on por menor o igual.}}
\symbolentry{\texttt{>=}}{\tok{GE}}{\nb{Comparaci\'on por mayor o igual.}}
\symbolentry{\texttt{<}}{\tok{LT}}{\nb{Comparaci\'on por menor estricto.}}
\symbolentry{\texttt{>}}{\tok{LT}}{\nb{Comparaci\'on por mayor estricto.}}
\symbolentry{\texttt{++}}{\tok{CONCAT}}{\nb{Operador de concatenaci\'on de listas.}}
\symbolentry{\texttt{+}}{\tok{PLUS}}{\nb{Suma de n\'umeros.}}
\symbolentry{\texttt{-}}{\tok{MINUS}}{\nb{Resta de n\'umeros y menos unario.}}
\symbolentry{\texttt{*}}{\tok{TIMES}}{\nb{Producto de n\'umeros.}}
\symbolentry{\texttt{\^}}{\tok{POW}}{\nb{Potencia.}}
\end{tabularx}\bigskip

\subsection{Pragmas}

El tokenizador implementa directivas pragma para
mantener registro de ``regiones''. Una regi\'on es una cadena de texto que
sirve para identificar o {\em taggear} un fragmento del programa.
Las regiones no tienen ning\'un significado
especial para el int\'erprete de Gobstones, pero todas las excepciones que
eleva el int\'erprete vienen acompa\~nadas de una posici\'on que incluye
el nombre de la regi\'on actual. Las regiones pueden anidarse.
Este comportamiento se implementa por medio de dos directivas.
\begin{itemize}
\item \str{/*@BEGIN\_REGION@\textit{nombre\_de\_la\_regi\'on}@*/}:
       mete el nombre de una regi\'on en la pila de regiones.
\item \str{/*@END\_REGION@*/}: saca la regi\'on del tope de la pila de regiones.
\end{itemize}
Por ejemplo ante el siguiente programa:
\begin{verbatim}
/*@BEGIN_REGION@A@*/
procedure P() {
  /*@BEGIN_REGION@B@*/
  x := f(
  /*@END_REGION@*/
}
/*@END_REGION@*/
\end{verbatim}
El parser idealmente deber\'ia reportar que hay un error de sintaxis en la regi\'on \texttt{B}.

\subsection{Gram\'atica}
Los s\'imbolos no terminales se describen con su nombre \s{enCursiva}.
Las producciones se escriben siguiendo las convenciones usuales de EBNF.
La gram\'atica es liberal en algunos sentidos. En particular:
\begin{itemize}
\item El \texttt{return}
se considera un {\em statement} que puede aparecer en la posici\'on en la que
podr\'ia aparecer cualquier otra instrucci\'on. La restricci\'on de que
el \texttt{return} \'unicamente aparezca como \'ultima instrucci\'on del bloque, y
\'unicamente al final de las declaraciones de funciones y del programa principal,
es una restricci\'on que se posterga para la etapa de chequeo sem\'antico
({\em lint}).
\item Se admite el gui\'on bajo (\chr{\_}) como un posible patr\'on en el lado
izquierdo de las ramas de un \texttt{switch} y en el lado izquierdo de las ramas de un.
\texttt{interactive program}.
En una lista de ramas deber\'ia haber un \'unico gui\'on bajo, y deber\'ia ser el \'ultimo
patr\'on de la lista pero esto, de nuevo, se relega a la etapa de lint.
\end{itemize}

Esta gram\'atica se puede expresar como LL(1) usando las t\'ecnicas
usuales (factorizando las producciones a izquierda y estratificando las expresiones en t\'erminos, factores, \'atomos, etc.).
Las convenciones de asociatividad y precedencia de operadores no se reflejan
en las producciones, sino por fuera.
\bigskip

\produccion{\s{start}}{\s{definition}*}

\produccion{\s{definition}}{
\s{defProgram}
\ALT
\s{defInteractiveProgram}
\ALT
\s{defProcedure}
\ALT
\s{defFunction}
\ALT
\s{defType}
}

\produccion{\s{defProgram}}{
  \tok{PROGRAM} \s{stmtBlock}
}

\produccion{\s{defInteractiveProgram}}{
  \TODO{TODO}
}

\produccion{\s{defProcedure}}{
  \tok{PROCEDURE} \tok{LPAREN} \s{loweridList} \tok{RPAREN} \s{stmtBlock}
}

\produccion{\s{defFunction}}{
  \tok{FUNCTION} \tok{LPAREN} \s{loweridList} \tok{RPAREN} \s{stmtBlock}
}

\produccion{\s{defType}}{
  \TODO{TODO}
}

\produccion{\s{loweridList}}{
  \EMPTY
\ALT
  \s{\nonEmpty{loweridList}}
}

\produccion{\s{\nonEmpty{loweridList}}}{
  \tok{LOWERID} (\tok{COMMA} \s{\nonEmpty{loweridList}})?
}

\noindent {\bf Statements.}

\produccion{\s{statement}}{
  \s{stmtBlock}
\ALT
  \s{stmtReturn}
\ALT
  \s{stmtIf}
\ALT
  \s{stmtRepeat}
\ALT
  \s{stmtForeach}
\ALT
  \s{stmtWhile}
\ALT
  \s{stmtSwitch}
\ALT
  \s{stmtLet}
\ALT
  \s{stmtVariableAssignment}
\ALT
  \s{stmtProcedureCall}
}

\produccion{\s{stmtBlock}}{
  \tok{LBRACE} (\s{statement} \tok{SEMICOLON}?)* \tok{RBRACE}
}

\produccion{\s{stmtReturn}}{
  \tok{RETURN} \s{exprTuple}
}

\produccion{\s{stmtIf}}{
  \tok{IF} \tok{LPAREN} \s{expression} \tok{RPAREN} 
           \tok{THEN}? \s{stmtBlock}
           (\tok{ELSE} \s{stmtBlock})?
}

\produccion{\s{stmtRepeat}}{
  \tok{REPEAT} \tok{LPAREN} \s{expression} \tok{RPAREN} \s{stmtBlock}
}

\produccion{\s{stmtForeach}}{
  \tok{FOREACH} \tok{LOWERID} \tok{IN} \s{expression} \s{stmtBlock}
}

\produccion{\s{stmtWhile}}{
  \tok{WHILE} \tok{LPAREN} \s{expression} \tok{RPAREN} \s{stmtBlock}
}

\produccion{\s{stmtSwitch}}{
  \tok{SWITCH} \tok{LPAREN} \s{expression} \tok{RPAREN} \tok{TO}? \tok{LBRACE} \s{stmtSwitchBranch}* \tok{RBRACE}
}

\produccion{\s{stmtSwitchBranch}}{
  \s{pattern} \tok{ARROW} \s{stmtBlock}
}

\produccion{\s{pattern}}{
  \s{patternWildcard}
\ALT
  \s{patternConstructor}
\ALT
  \s{patternTuple}
}

\produccion{\s{patternWildcard}}{
  \tok{UNDERSCORE}
}

\produccion{\s{patternConstructor}}{
  \tok{UPPERID} (\tok{LPAREN} \s{loweridList} \tok{RPAREN})?
}

\produccion{\s{patternTuple}}{
  \tok{LPAREN} \tok{RPAREN}
\ALT
  \tok{LPAREN} \tok{LOWERID} \tok{COMMA} \s{\nonEmpty{loweridList}} \tok{RPAREN}
}


\produccion{\s{stmtLet}}{
  \tok{LET} \s{stmtVariableAssignment}
\ALT
  \tok{LET} \s{stmtTupleAssignment}
}

\produccion{\s{stmtVariableAssignment}}{
  \tok{LOWERID} \tok{ASSIGN} \s{expression}
}

\produccion{\s{stmtTupleAssignment}}{
  \tok{LPAREN} \tok{RPAREN} \tok{ASSIGN} \s{expression}
\ALT
  \tok{LPAREN} \tok{LOWERID} \tok{COMMA} \s{\nonEmpty{loweridList}} \tok{RPAREN} \tok{ASSIGN} \s{expression}
}

\produccion{\s{stmtProcedureCall}}{
  \TODO{TODO}
}

\noindent {\bf Expressions.}

\produccion{\s{expression}}{
  \TODO{TODO}
}

\produccion{\s{exprTuple}}{
  \tok{LPAREN} \s{expressionList} \tok{RPAREN}
}

\produccion{\s{expressionList}}{
  \EMPTY
\ALT
  \s{\nonEmpty{expressionList}}
}

\produccion{\s{\nonEmpty{expressionList}}}{
  \s{expression} (\tok{COMMA} \s{\nonEmpty{expressionList}})?
}


\end{document}
